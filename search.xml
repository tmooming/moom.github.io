<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【NLP】自然语言处理 完整流程</title>
    <url>/p/6cde8e09.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>BECOME IMMORTAL求解思路</title>
    <url>/p/10003.html</url>
    <content><![CDATA[<p><strong>题目如下：</strong></p>
<blockquote>
<p><a href="https://www.codewars.com/kata/become-immortal/" target="_blank" rel="noopener"><strong>BECOME IMMORTAL</strong></a></p>
<blockquote>
<p>Instructions</p>
<p>In the nation of CodeWars, there lives an Elder who has lived for a long time. Some people call him the Grandpatriarch, but most people just refer to him as the Elder.</p>
<p>There is a secret to his longetivity: he has a lot of <code>young</code> worshippers, who regularly perform a ritual to ensure that the Elder stays immortal:</p>
<ul>
<li><p>The worshippers lines up in a magic rectangle, of dimensions <code>m</code> and <code>n</code>.</p>
</li>
<li><p>They channel their will to wish for the Elder. In this magic rectangle, any worshipper can donate time equal to the <code>xor</code> of the column and the row (zero-indexed) he’s on, in seconds, to the Elder.</p>
</li>
<li><p>However, not every ritual goes perfectly. The donation of time from the worshippers to the Elder will experience a transmission loss <code>l</code> (in seconds). Also, if a specific worshipper cannot channel more than <code>l</code> seconds, the Elder will not be able to receive this worshipper’s donation.</p>
</li>
</ul>
<p>The estimated age of the Elder is so old it’s probably bigger than the total number of atoms in the universe. However, the lazy programmers (who <code>made a big news</code> by inventing <a href="https://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs" target="_blank" rel="noopener">the Y2K bug and other related things</a>) apparently didn’t think thoroughly enough about this, and so their <code>simple</code> date-time system can only record time from 0 to <code>t-1</code> seconds. If the elder received the total amount of time (in seconds) more than the system can store, it will be wrapped around so that the time would be between the range 0 to <code>t-1</code>.</p>
<p>Given <code>m</code>, <code>n</code>, <code>l</code> and <code>t</code>, please find the number of seconds the Elder has received, represented in the poor programmer’s date-time system.</p>
<p>(Note: <code>t</code> will never be bigger than <code>2^32 - 1</code>, and in JS, <code>2^26 - 1</code>.)</p>
</blockquote>
</blockquote>
<p>我的解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elder_age</span><span class="params">(m,n,l,t)</span>:</span></span><br><span class="line">    matirc = (max((j^i)-l,<span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(m) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> sum(matirc)%t</span><br></pre></td></tr></table></figure>

<p>正确结果比较容易求出来，这道题目的难点在于对程序的优化，刚开始想用列表生成式，发现运行时间太长了，就改成了generator，同时这个方法占内存太多，所以算是最粗糙的一个解法了，以后想到了再重新写。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Lab 简单配置</title>
    <url>/p/10002.html</url>
    <content><![CDATA[<p>使用 JupyterLab，你可以：</p>
<ul>
<li>可以开启终端，用于交互式运行代码，完全支持丰富的输出</li>
<li>完美支持 Markdown，Python，R，Julia，LaTeX等任何文本文件</li>
<li>增强notebook功能</li>
<li>超多插件支持</li>
</ul>
<h3 id="Jupyter-Lab安装"><a href="#Jupyter-Lab安装" class="headerlink" title="Jupyter Lab安装"></a>Jupyter Lab安装</h3><blockquote>
<p>默认你已经安装了conda</p>
</blockquote>
<h4 id="第一种办法-命令行安装"><a href="#第一种办法-命令行安装" class="headerlink" title="第一种办法 命令行安装"></a>第一种办法 命令行安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载jupyterlab</span><br><span class="line">pip install jupyterlab</span><br><span class="line"># 安装ipython</span><br><span class="line">pip install ipython</span><br></pre></td></tr></table></figure>

<h4 id="第二种办法-进入conda图形化界面安装"><a href="#第二种办法-进入conda图形化界面安装" class="headerlink" title="第二种办法 进入conda图形化界面安装"></a>第二种办法 进入conda图形化界面安装</h4><p>点这个，就能启动conda了。</p>
<p>进入界面你就知道怎么安装了。如果还不会，请自行百度。</p>
<p><strong>要注意的是，请在合适的python虚拟环境中安装（如果你有多个虚拟环境），这样会省事些。</strong></p>
<h4 id="Jupyter-Lab-插件安装"><a href="#Jupyter-Lab-插件安装" class="headerlink" title="Jupyter Lab 插件安装"></a>Jupyter Lab 插件安装</h4><p>首先是Jupyter Lab的工作目录的设置，这个和Jupyter notebook的设置是一样的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 如果不放心，可以再来一遍</span><br><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure>

<p>接着就是插件安装了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装一个生成目录的插件</span><br><span class="line">jupyter labextension install @jupyterlab&#x2F;toc</span><br><span class="line"># 可以查看一下安装的插件</span><br><span class="line">jupyter labextension list</span><br></pre></td></tr></table></figure>

<p>安装完后，打开cmd，输入jupyter lab 进入Jupyter Lab界面。</p>
<p>点击 Settings –&gt; Advanced Settings Editor ，将Extension Manager 里的enabled 的 false 改成 true（在右边的里面改）。</p>
<p>现在，看向界面左侧应该就可以看到一个插件管理的图标，点击就可以看到刚才安装的插件</p>
<p>这个插件还有查询功能，我们可以很方便的安装卸载插件，上面是已安装的插件，下面是可以安装的插件，安装完成后可以直接更新。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>python中yield用法解析</title>
    <url>/p/10001.html</url>
    <content><![CDATA[<p><strong>直接上例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"程序开始"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"进入循环"</span>)</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">        print(<span class="string">"单次循环结束"</span>)</span><br><span class="line">    print(<span class="string">"循环结束"</span>)</span><br><span class="line">g = test()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p><strong>简单的几行代码就让你明白什么是yield，代码的输出这个：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序开始</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">**********</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>接下来逐步解释测试程序的执行：</p>
<ol>
<li><p>程序开始执行以后，因为test函数中有yield关键字，所以test函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
</li>
<li><p>直到调用next方法，test函数正式开始执行，先执行test函数中的print方法，然后进入while循环</p>
</li>
<li><p>程序遇到yield关键字，然后把yield想想成return,return了一个5之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前三行（第一个是while上面的print的结果，第二个是while里面的print的结果，第三个是return出的结果）是执行print(next(g))的结果，</p>
</li>
<li><p>程序执行print(“*”*10)，输出10个*</p>
</li>
<li><p>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p>
</li>
<li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出5，然后程序停止，print函数输出的5就是这次return出的5.</p>
</li>
<li><p>最后再重复一次，这一次我们调用了send()函数，可以理解为给迭代器g 传递了一个参数，所以能输出res：7。</p>
</li>
</ol>
<p>通过上面这个例子，再结合yield的概念，就能知道yield到底有什么作用了：</p>
<p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从test函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>生有涯而知无涯</title>
    <url>/p/10000.html</url>
    <content><![CDATA[<p>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
