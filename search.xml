<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BECOME IMMORTAL求解思路</title>
    <url>/p/10003/</url>
    <content><![CDATA[<p><strong>题目如下：</strong></p>
<blockquote>
<p><a href="https://www.codewars.com/kata/become-immortal/"><strong>BECOME IMMORTAL</strong></a></p>
<blockquote>
<p>Instructions</p>
<p>In the nation of CodeWars, there lives an Elder who has lived for a long time. Some people call him the Grandpatriarch, but most people just refer to him as the Elder.</p>
<p>There is a secret to his longetivity: he has a lot of <code>young</code> worshippers, who regularly perform a ritual to ensure that the Elder stays immortal:</p>
<ul>
<li><p>The worshippers lines up in a magic rectangle, of dimensions <code>m</code> and <code>n</code>.</p>
</li>
<li><p>They channel their will to wish for the Elder. In this magic rectangle, any worshipper can donate time equal to the <code>xor</code> of the column and the row (zero-indexed) he’s on, in seconds, to the Elder.</p>
</li>
<li><p>However, not every ritual goes perfectly. The donation of time from the worshippers to the Elder will experience a transmission loss <code>l</code> (in seconds). Also, if a specific worshipper cannot channel more than <code>l</code> seconds, the Elder will not be able to receive this worshipper’s donation.</p>
</li>
</ul>
<p>The estimated age of the Elder is so old it’s probably bigger than the total number of atoms in the universe. However, the lazy programmers (who <code>made a big news</code> by inventing <a href="https://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs">the Y2K bug and other related things</a>) apparently didn’t think thoroughly enough about this, and so their <code>simple</code> date-time system can only record time from 0 to <code>t-1</code> seconds. If the elder received the total amount of time (in seconds) more than the system can store, it will be wrapped around so that the time would be between the range 0 to <code>t-1</code>.</p>
<p>Given <code>m</code>, <code>n</code>, <code>l</code> and <code>t</code>, please find the number of seconds the Elder has received, represented in the poor programmer’s date-time system.</p>
<p>(Note: <code>t</code> will never be bigger than <code>2^32 - 1</code>, and in JS, <code>2^26 - 1</code>.)</p>
</blockquote>
</blockquote>
<p>我的解法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elder_age</span>(<span class="params">m,n,l,t</span>):</span></span><br><span class="line">    matirc = (<span class="built_in">max</span>((j^i)-l,<span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(matirc)%t</span><br></pre></td></tr></table></figure>
<p>正确结果比较容易求出来，这道题目的难点在于对程序的优化，刚开始想用列表生成式，发现运行时间太长了，就改成了generator，同时这个方法占内存太多，所以算是最粗糙的一个解法了，以后想到了再重新写。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>刷题</tag>
        <tag>codewars</tag>
      </tags>
  </entry>
  <entry>
    <title>Dataframe拼接操作报错</title>
    <url>/p/10006/</url>
    <content><![CDATA[<p>今天在优化一个程序时遇到的问题，记录一下。</p>
<p>这是一个对csv文件中的字段导入为Dataframe格式，然后计算相似度的程序，因为数据量很大，需要两个小时才能跑完，所以决定进行并行化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line">num = mp.cpu_count()-<span class="number">1</span></span><br><span class="line">    pool = mp.Pool(processes=num)</span><br><span class="line">    df_split = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(df), <span class="built_in">len</span>(df)//num):</span><br><span class="line">        <span class="comment"># 原本写的</span></span><br><span class="line">        <span class="comment"># df_split.append(df.iloc[i:min(i + len(df)//num, len(df)),:])</span></span><br><span class="line">        <span class="comment"># 修改后</span></span><br><span class="line">        df_split.append(df.iloc[i:<span class="built_in">min</span>(i + <span class="built_in">len</span>(df)//num, <span class="built_in">len</span>(df)),:].reset_index())</span><br><span class="line">    <span class="comment"># mllistBZ是自己写的方法，传入Dataframe格式，返回的也是Dataframe格式</span></span><br><span class="line">    df = pd.concat(pool.<span class="built_in">map</span>(mllistBZ, df_split))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    df.to_csv(<span class="string">&#x27;标准化.csv&#x27;</span>, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>在晚上找了资料，写完后运行就报错。最后排查发现是因为Dataframe在拆分后再合并，其下标就不对了，需要进行reset_index（）。否则就会报如下错误。不过，如果仅仅是打印出来，也是不会报错的。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/multiprocessing/pool.py&quot;</span>, <span class="built_in">line</span> <span class="number">121</span>, in worker</span><br><span class="line">    result = (True, func(*<span class="keyword">args</span>, **kwds))</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/multiprocessing/pool.py&quot;</span>, <span class="built_in">line</span> <span class="number">44</span>, in mapstar</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">list</span>(<span class="keyword">map</span>(*<span class="keyword">args</span>))</span><br><span class="line">  File <span class="string">&quot;biaozhunhua.py&quot;</span>, <span class="built_in">line</span> <span class="number">128</span>, in mllistBZ</span><br><span class="line">    <span class="keyword">if</span> document[<span class="string">&#x27;其他&#x27;</span>][i] == <span class="string">&#x27;&#x27;</span> <span class="built_in">or</span> document[<span class="string">&#x27;其他&#x27;</span>][i] <span class="keyword">is</span> np.nan:</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/site-packages/pandas/core/series.py&quot;</span>, <span class="built_in">line</span> <span class="number">868</span>, in __getitem__</span><br><span class="line">    result = self.<span class="built_in">index</span>.get_value(self, key)</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/site-packages/pandas/core/indexes/base.py&quot;</span>, <span class="built_in">line</span> <span class="number">4375</span>, in get_value</span><br><span class="line">    tz=getattr(series.dtype, <span class="string">&#x27;tz&#x27;</span>, None))</span><br><span class="line">  File <span class="string">&quot;pandas/_libs/index.pyx&quot;</span>, <span class="built_in">line</span> <span class="number">81</span>, in pandas._libs.<span class="built_in">index</span>.IndexEngine.get_value</span><br><span class="line">  File <span class="string">&quot;pandas/_libs/index.pyx&quot;</span>, <span class="built_in">line</span> <span class="number">89</span>, in pandas._libs.<span class="built_in">index</span>.IndexEngine.get_value</span><br><span class="line">  File <span class="string">&quot;pandas/_libs/index.pyx&quot;</span>, <span class="built_in">line</span> <span class="number">132</span>, in pandas._libs.<span class="built_in">index</span>.IndexEngine.get_loc</span><br><span class="line">  File <span class="string">&quot;pandas/_libs/hashtable_class_helper.pxi&quot;</span>, <span class="built_in">line</span> <span class="number">987</span>, in pandas._libs.hashtable.Int64HashTable.get_item</span><br><span class="line">  File <span class="string">&quot;pandas/_libs/hashtable_class_helper.pxi&quot;</span>, <span class="built_in">line</span> <span class="number">993</span>, in pandas._libs.hashtable.Int64HashTable.get_item</span><br><span class="line">KeyError: <span class="number">0</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="comment">&quot;</span></span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  File <span class="string">&quot;biaozhunhua.py&quot;</span>, <span class="built_in">line</span> <span class="number">195</span>, in <span class="symbol">&lt;module&gt;</span></span><br><span class="line">    run(df)</span><br><span class="line">  File <span class="string">&quot;biaozhunhua.py&quot;</span>, <span class="built_in">line</span> <span class="number">162</span>, in run</span><br><span class="line">    df = pd.concat(pool.<span class="keyword">map</span>(mllistBZ, df_split))</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/multiprocessing/pool.py&quot;</span>, <span class="built_in">line</span> <span class="number">268</span>, in <span class="keyword">map</span></span><br><span class="line">    <span class="keyword">return</span> self._map_async(func, iterable, mapstar, chunksize).<span class="built_in">get</span>()</span><br><span class="line">  File <span class="string">&quot;/home/turw/anaconda3/lib/python3.7/multiprocessing/pool.py&quot;</span>, <span class="built_in">line</span> <span class="number">657</span>, in <span class="built_in">get</span></span><br><span class="line">    raise self._value</span><br><span class="line">KeyError: <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pandas</tag>
        <tag>Dataframe</tag>
        <tag>并行</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Lab 简单配置</title>
    <url>/p/10002/</url>
    <content><![CDATA[<p>使用 JupyterLab，你可以：</p>
<ul>
<li>可以开启终端，用于交互式运行代码，完全支持丰富的输出</li>
<li>完美支持 Markdown，Python，R，Julia，LaTeX等任何文本文件</li>
<li>增强notebook功能</li>
<li>超多插件支持</li>
</ul>
<h3 id="Jupyter-Lab安装"><a href="#Jupyter-Lab安装" class="headerlink" title="Jupyter Lab安装"></a>Jupyter Lab安装</h3><blockquote>
<p>默认你已经安装了conda</p>
</blockquote>
<h4 id="第一种办法-命令行安装"><a href="#第一种办法-命令行安装" class="headerlink" title="第一种办法 命令行安装"></a>第一种办法 命令行安装</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载jupyterlab</span></span><br><span class="line">pip <span class="keyword">install </span><span class="keyword">jupyterlab</span></span><br><span class="line"><span class="keyword"># </span>安装ipython</span><br><span class="line">pip <span class="keyword">install </span>ipython</span><br></pre></td></tr></table></figure>
<h4 id="第二种办法-进入conda图形化界面安装"><a href="#第二种办法-进入conda图形化界面安装" class="headerlink" title="第二种办法 进入conda图形化界面安装"></a>第二种办法 进入conda图形化界面安装</h4><p>点这个，就能启动conda了。</p>
<p>进入界面你就知道怎么安装了。如果还不会，请自行百度。</p>
<p><strong>要注意的是，请在合适的python虚拟环境中安装（如果你有多个虚拟环境），这样会省事些。</strong></p>
<h4 id="Jupyter-Lab-插件安装"><a href="#Jupyter-Lab-插件安装" class="headerlink" title="Jupyter Lab 插件安装"></a>Jupyter Lab 插件安装</h4><p>首先是Jupyter Lab的工作目录的设置，这个和Jupyter notebook的设置是一样的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"># 如果不放心，可以再来一遍</span><br><span class="line">jupyter lab --<span class="keyword">generate</span>-<span class="keyword">config</span></span><br></pre></td></tr></table></figure>
<p>接着就是插件安装了</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装一个生成目录的插件</span></span><br><span class="line"><span class="keyword">jupyter </span>labextension <span class="keyword">install </span>@<span class="keyword">jupyterlab/toc</span></span><br><span class="line"><span class="keyword"># </span>可以查看一下安装的插件</span><br><span class="line"><span class="keyword">jupyter </span>labextension list</span><br></pre></td></tr></table></figure>
<p>安装完后，打开cmd，输入jupyter lab 进入Jupyter Lab界面。</p>
<p>点击 Settings –&gt; Advanced Settings Editor ，将Extension Manager 里的enabled 的 false 改成 true（在右边的里面改）。</p>
<p>现在，看向界面左侧应该就可以看到一个插件管理的图标，点击就可以看到刚才安装的插件</p>
<p>这个插件还有查询功能，我们可以很方便的安装卸载插件，上面是已安装的插件，下面是可以安装的插件，安装完成后可以直接更新。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Jupyter</tag>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.0.4 安装 Pycharm2019.3</title>
    <url>/p/10008/</url>
    <content><![CDATA[<p><strong>首先声明： 本教程适用于PyCharm所有版本，其他jetbrains系列产品（Pycharm、Idea、WebStorm等也适用。</strong></p>
<ol start="0">
<li><p>清除原本遗留的Pycharm(如果是第一次安装，可以跳过此步骤)：</p>
<ul>
<li><p>删除pycharm文件夹</p>
</li>
<li><p>删除 .pycharm文件，这个文件是在<strong>当前用户</strong>的家目录下：</p>
<p><img src="/p/10008/image-20200408093746643.png" alt=".PyCharm文件位置"></p>
</li>
</ul>
</li>
</ol>
<h2 id="激活步骤"><a href="#激活步骤" class="headerlink" title="激活步骤:"></a>激活步骤:</h2><ol>
<li><p><strong>下载安装补丁：</strong></p>
<p>链接：<a href="https://pan.baidu.com/s/1gbXVAbtlXPqHwdv2Jjw_DQ">https://pan.baidu.com/s/1gbXVAbtlXPqHwdv2Jjw_DQ</a> </p>
<p>提取码：rbjz </p>
<p>（其他版本的安装补丁也是可以的）</p>
</li>
<li><p><strong>安装完成启的IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE。</strong></p>
<p><img src="/p/10008/LuuSIJ1HOJ89wWIX.png" alt="选择**Evaluate for free**"></p>
</li>
<li><p><strong>将 jetbrains-agent-latest.zip拖进下面IDE窗口，点 “Restart” 按钮重启IDE。</strong></p>
<p><img src="/p/10008/hH6pRfYFLFAeePVp.png" alt="拖入"></p>
<p>如果已经打开项目，直接将 jetbrains-agent-latest.zip包拖到代码区，即可</p>
<p><img src="/p/10008/image-20200408094923358.png" alt="拖入到代码区"></p>
</li>
<li><p><strong>在弹出的JetbrainsAgent Helper对话框中，选择激活方式，点击安装按钮，**</strong>网络不好，建议勾选我无法访问外网。**</p>
<p><img src="/p/10008/image-20200408095309849.png"></p>
</li>
<li><p><strong>重启IDE，在Help—&gt;about中查看是否激活。</strong></p>
<p><img src="/p/10008/UKbfjpMtLuQKVRIT.png" alt="激活完成"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>gitalk配置问题</title>
    <url>/p/10007/</url>
    <content><![CDATA[<p>今天跟着网上给自己的博客配置gitalk评论功能，在配置完成后怎么都不对，看网页中控制台的报错信息是Container not found, document.getElementById: ${container} 这个报错信息，</p>
<p>然后搜教程说可能是 comments.swig 文件里面的代码贴错位置了，但我就是跟着教程做的，如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  正确示例</span></span><br><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;comments&quot;</span> id=<span class="string">&quot;comments&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">    &#123;% elseif theme.gitalk.enable %&#125;            <span class="comment">//  将复制的两行代码贴在这个位置</span></span><br><span class="line">    &lt;div id=<span class="string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//  错误示例</span></span><br><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;comments&quot;</span> id=<span class="string">&quot;comments&quot;</span>&gt;&lt;/div&gt;  </span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"> </span><br><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">&lt;div id=<span class="string">&quot;gitalk-container&quot;</span>&gt;&lt;/div&gt;   </span><br></pre></td></tr></table></figure>
<p>我之前写的就是正确示例这样，就是怎么都不显示，然后我干脆改成<strong>错误示例</strong>的样子，结果就出来了！！！！我觉得就是elif的逻辑判断问题，不能嵌套。</p>
<p>另外，在第一次配置后，可能会在评论区显示，没有相关issue，请联系xxx。这个就需要自己想在博客中登录github账号，就能正常显示了。</p>
<p>完美~</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>gitalk</tag>
        <tag>next</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>no matching manifest for windows/amd64 10.0.18362 in the manifest list entri</title>
    <url>/p/10005/</url>
    <content><![CDATA[<p>Windows下使用docker 下载镜像时 报错：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">no</span> matching manifest for windows/amd<span class="number">64</span> <span class="number">10</span>.<span class="number">0</span>.<span class="number">18362</span> in the manifest list entri</span><br></pre></td></tr></table></figure>
<p>或者是另一种错误：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">image operating <span class="keyword">system</span> <span class="string">&quot;linux&quot;</span> cannot be used <span class="keyword">on</span> <span class="title">this</span> <span class="title">platform</span></span><br></pre></td></tr></table></figure>
<p>都是同一种解决方案：设置daemon.json的experimental:true</p>
<p><img src="/p/10005/20200106010842.png" alt="Daemon设置"></p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>Kitematic</tag>
      </tags>
  </entry>
  <entry>
    <title>python字符串形式的列表转列表</title>
    <url>/p/10011/</url>
    <content><![CDATA[<p>每次要将str转换为list时都忘记了方法名，遂记录一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如 a = &#x27;[&#x27;b&#x27;,&#x27;cc&#x27;,&#x27;d&#x27;]&#x27;</span></span><br><span class="line">str2list = ast.literal_eval(a)</span><br><span class="line"><span class="comment"># out put: [&#x27;b&#x27;,&#x27;cc&#x27;,&#x27;d&#x27;]</span></span><br><span class="line"><span class="comment"># 其他方法都不靠谱</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>格式转换</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python中yield用法解析</title>
    <url>/p/10001/</url>
    <content><![CDATA[<p><strong>直接上例子：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    print(<span class="string">&quot;程序开始&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">&quot;进入循环&quot;</span>)</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">        print(<span class="string">&quot;res:&quot;</span>,res)</span><br><span class="line">        print(<span class="string">&quot;单次循环结束&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;循环结束&quot;</span>)</span><br><span class="line">g = test()</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">10</span>)</span><br><span class="line">print(<span class="built_in">next</span>(g))</span><br><span class="line">print(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>
<p><strong>简单的几行代码就让你明白什么是yield，代码的输出这个：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序开始</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">**********</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>接下来逐步解释测试程序的执行：</p>
<ol>
<li><p>程序开始执行以后，因为test函数中有yield关键字，所以test函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p>
</li>
<li><p>直到调用next方法，test函数正式开始执行，先执行test函数中的print方法，然后进入while循环</p>
</li>
<li><p>程序遇到yield关键字，然后把yield想想成return,return了一个5之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前三行（第一个是while上面的print的结果，第二个是while里面的print的结果，第三个是return出的结果）是执行print(next(g))的结果，</p>
</li>
<li><p>程序执行print(“*”*10)，输出10个*</p>
</li>
<li><p>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p>
</li>
<li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出5，然后程序停止，print函数输出的5就是这次return出的5.</p>
</li>
<li><p>最后再重复一次，这一次我们调用了send()函数，可以理解为给迭代器g 传递了一个参数，所以能输出res：7。</p>
</li>
</ol>
<p>通过上面这个例子，再结合yield的概念，就能知道yield到底有什么作用了：</p>
<p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从test函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.0.4安装pgadmin4及问题解决</title>
    <url>/p/10009/</url>
    <content><![CDATA[<p><strong>首先，安装的方法千千万，适合自己的没几个</strong></p>
<p>我主要是按照这个流程安装的，主要记录一下其中遇到的问题。</p>
<p> <a href="https://www.digitalocean.com/community/tutorials/how-to-install-configure-pgadmin4-server-mode">https://www.digitalocean.com/community/tutorials/how-to-install-configure-pgadmin4-server-mode</a></p>
<h3 id="第一步：安装apache2"><a href="#第一步：安装apache2" class="headerlink" title="第一步：安装apache2"></a>第一步：安装apache2</h3><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> apt update</span><br><span class="line">sudo apt install apache2</span><br><span class="line">sudo ufw app list  <span class="comment"># 这一步其实可以跳过，只要是安装成功了，这个肯定能符合</span></span><br><span class="line">sudo ufw allow <span class="string">&#x27;Apache&#x27;</span></span><br><span class="line">sudo ufw status  <span class="comment"># 不放心的话，可以看看</span></span><br><span class="line">sudo systemctl status apache2  <span class="comment"># 这个还是看看的好</span></span><br></pre></td></tr></table></figure>
<p>安装完成apache后，就可以通过<a href="http://your_server_ip访问自己的主页了./">http://your_server_ip访问自己的主页了。</a></p>
<p>（注，通过[ hostname -I ]命令可以获取自己本机ip地址）</p>
<p><img src="/p/10009/small_apache_default.png" alt="Apache default page"></p>
<p>其他的就不用设置了。</p>
<h3 id="第二步：安装anaconda3"><a href="#第二步：安装anaconda3" class="headerlink" title="第二步：安装anaconda3"></a>第二步：安装anaconda3</h3><p>安装过程就跳过了。</p>
<p>唯一需要注意的一点是，在激活虚拟环境后，怎么看当前的python路径，这个也是后面需要用到的（我就是在这个地方卡了很久）</p>
<p>我只推荐一个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先在终端输入python，进入命令行模式</span></span><br><span class="line">&gt;&gt; <span class="keyword">import</span> sys </span><br><span class="line">&gt;&gt; pathn = sys.executable</span><br><span class="line">&gt;&gt; print(path)</span><br></pre></td></tr></table></figure>
<p>这个目录需要记住</p>
<h3 id="第三步：安装postgresql12"><a href="#第三步：安装postgresql12" class="headerlink" title="第三步：安装postgresql12"></a>第三步：安装postgresql12</h3><p>这个我试了好几个方法，源码安装还是不推荐，太繁琐，还容易出错（我承认我没成功）。</p>
<p>所以还是用最简单的方法吧。</p>
<p>首先，先掌握一下，怎么彻底删除软件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove --purge 软件名称  </span><br><span class="line">sudo apt-get autoremove --purge 软件名称 </span><br><span class="line">dpkg -l |grep ^rc|awk &#x27;&#123;print $2&#125;&#x27; |sudo xargs dpkg -P  # 清理残留数据</span><br></pre></td></tr></table></figure>
<p>只有学会了娴熟的卸载软件，才能在安装失败后重新安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql  # 现在能自动安装postgresql 12了</span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo apt-get install postgresql-12 <span class="comment"># 太坑，不要指定版本安装</span></span></span><br></pre></td></tr></table></figure>
<p>在失败了一天后，我就是通过上述两个命令，安装成功了。。。。</p>
<h3 id="第四步：安装pgadmin4"><a href="#第四步：安装pgadmin4" class="headerlink" title="第四步：安装pgadmin4"></a>第四步：安装pgadmin4</h3><p>最重要的一步来了！！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update  # 没事就update一下</span><br><span class="line">sudo apt install libgmp3-dev libpq-dev libapache2-mod-wsgi-py3  # 一定要安装</span><br><span class="line">sudo mkdir -p /var/lib/pgadmin4/sessions</span><br><span class="line">sudo mkdir /var/lib/pgadmin4/storage</span><br><span class="line">sudo mkdir /var/log/pgadmin4</span><br><span class="line">sudo chown -R 用户名:用户名 /var/lib/pgadmin4  # 为了保持一致，我推荐用postgres</span><br><span class="line">sudo chown -R 用户名:用户名 /var/log/pgadmin4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后后面的就和我看到的教程不一样了，因为我用的conda，我在网上看到的虚拟环境，全都是用pyvenv或者其他的。</p>
<p>首先，我使用的虚拟环境，就是conda自带的base，没有使用自己新建的。</p>
<p>然后，接着来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vi anaconda3/lib/python3.7/site-packages/pgadmin4/config_local.py  # 我推荐用vim编辑，nano太花，然后，因为我是用默认的虚拟环境base，所以直接是anaconda3/lib,如果是自建的虚拟环境，一般就是anaconda3/envs/名字/lib。。。</span><br></pre></td></tr></table></figure>
<p>插入内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LOG_FILE = &#x27;/var/log/pgadmin4/pgadmin4.log&#x27;  # 这定义了pgAdmin日志将存储在其中的文件。</span><br><span class="line">SQLITE_PATH = &#x27;/var/lib/pgadmin4/pgadmin4.db&#x27;  # pgAdmin将与用户相关的数据存储在SQLite数据库中，该指令将pgAdmin软件指向此配置数据库。由于此文件位于永久目录下/var/lib/pgadmin4/，因此升级后用户数据不会丢失。</span><br><span class="line">SESSION_DB_PATH = &#x27;/var/lib/pgadmin4/sessions&#x27; # 指定将用于存储会话数据的目录。</span><br><span class="line">STORAGE_DIR = &#x27;/var/lib/pgadmin4/storage&#x27; # 定义pgAdmin将在何处存储其他数据，例如备份和安全证书。</span><br><span class="line">SERVER_MODE = True  # 设置此伪指令以True告诉pgAdmin在服务器模式下运行，而不是在桌面模式下运行。</span><br></pre></td></tr></table></figure>
<p>然后，开始安装pgadmin4:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python my_env/lib/python3.6/site-packages/pgadmin4/setup.py  # 在这一步，很可能因为版本冲突而报错，我遇到了no model name &#x27;sqlalchemy.dialects.postgresql&#x27;的错误，网上也没看到解决办法，我选择了先卸载（1.3.X版本），再安装低版本（1.2.x版本），就没事了，其他的模块错误，都是如此</span><br><span class="line">conda list sqlalchemy  # 查看conda中可供安装的不同版本，默认安装都是最新的</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">Output</span></span><br><span class="line"><span class="string">.</span> <span class="string">.</span> <span class="string">.</span></span><br><span class="line"><span class="attr">Enter the email address and password to use for the initial pgAdmin user account:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Email address:</span> <span class="string">postgres@postgres.com</span>   <span class="comment"># 随便输入</span></span><br><span class="line"><span class="attr">Password:</span> </span><br><span class="line"><span class="attr">Retype password:</span></span><br></pre></td></tr></table></figure>
<p>之后，停用虚拟环境：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda deactivate</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 调用您在config_local.py文件中指定的文件路径。这些文件保存在您在步骤1中创建的目录中，这些目录当前由您的非root用户拥有。但是，运行Web服务器的用户和组必须可以访问它们。在Ubuntu 18.04上，默认情况下，这些是www-data用户和组，因此请更新以下目录的权限，以对这两个目录都具有www-data所有权：</span></span><br><span class="line">sudo chown -R www-data:www-data /var/lib/pgadmin4/ </span><br><span class="line">sudo chown -R www-data:www-data /var/log/pgadmin4/</span><br></pre></td></tr></table></figure>
<p>然后，配置apache</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在/sites-available/目录中创建一个新文件pgadmin4.conf。这将是服务器的虚拟主机文件：</span></span><br><span class="line">sudo vi /etc/apache2/sites-available/pgadmin4.conf  </span><br></pre></td></tr></table></figure>
<p><strong>重点来了</strong></p>
<p>教程中给出的内容是：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="section">&lt;VirtualHost *&gt;</span></span><br><span class="line">    <span class="attribute"><span class="nomarkup">ServerName</span></span> your_server_ip</span><br><span class="line"></span><br><span class="line">    <span class="attribute">WSGIDaemonProcess</span> pgadmin processes=<span class="number">1</span> threads=<span class="number">25</span> python-path=/home/ubuntu/anaconda<span class="number">3</span>/bin/python  #这是我的,应该改成之前输出的python路径</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">WSGIScriptAlias</span> / /home/ubuntu/anaconda<span class="number">3</span>/lib/python<span class="number">3</span>.<span class="number">6</span>/site-packages/pgadmin<span class="number">4</span>/pgAdmin<span class="number">4</span>.wsgi</span><br><span class="line"></span><br><span class="line">    <span class="section">&lt;Directory <span class="string">&quot;/home/ubuntu/anaconda3/lib/python3.6/site-packages/pgadmin4/&quot;</span>&gt;</span></span><br><span class="line">        <span class="attribute">WSGIProcessGroup</span> pgadmin</span><br><span class="line">        <span class="attribute">WSGIApplicationGroup</span> <span class="variable">%&#123;GLOBAL&#125;</span></span><br><span class="line">        <span class="attribute">Require</span> <span class="literal">all</span> granted</span><br><span class="line">    <span class="section">&lt;/Directory&gt;</span></span><br><span class="line"><span class="section">&lt;/VirtualHost&gt;</span></span><br></pre></td></tr></table></figure>
<p>保存并关闭虚拟主机文件。接下来，使用<code>a2dissite</code>脚本禁用默认虚拟主机文件<code>000-default.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2dissite 000-default.conf</span><br><span class="line">sudo a2ensite pgadmin4.conf  # 然后使用a2ensite脚本启用您的pgadmin4.conf虚拟主机文件。这将创建从/sites-available/目录中的虚拟主机文件到目录的符号链接/sites-enabled/：</span><br></pre></td></tr></table></figure>
<p>然后，测试配置文件的语法是否正确：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apachectl configtest</span><br></pre></td></tr></table></figure>
<p>如果您的配置文件全部正常，您将看到<code>Syntax OK</code>。</p>
<p>如果出现错误：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">AH00526: <span class="keyword">Syntax</span> <span class="keyword">error</span> <span class="keyword">on</span> <span class="keyword">line</span> 1 of /etc/apache2/sites-enabled/pgadmin4.<span class="keyword">conf</span>:</span><br><span class="line">Name <span class="keyword">duplicates</span> previous WSGI daemon definition.</span><br><span class="line">Action &#x27;configtest&#x27; failed.</span><br><span class="line">The Apache <span class="keyword">error</span> <span class="keyword">log</span> may have <span class="keyword">more</span> information.</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo a2enmod wsgi  # 用这个命令启动wsgi，启动失败就是wsgi没装上</span><br></pre></td></tr></table></figure>
<p>最后一步：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br></pre></td></tr></table></figure>
<h3 id="访问pgAdmin"><a href="#访问pgAdmin" class="headerlink" title="访问pgAdmin"></a>访问pgAdmin</h3><p>在本地计算机上，打开首选的Web浏览器，然后导航到服务器的IP地址：<a href="http://your_server_ip/">http://your_server_ip</a></p>
<p><img src="/p/10009/pgadmin_login_blank.png" alt="pgAdmin登录屏幕"></p>
]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>pgadmin4</tag>
        <tag>postgresql</tag>
        <tag>apache</tag>
        <tag>anaconda3</tag>
      </tags>
  </entry>
  <entry>
    <title>win10安装 Net Framework 3.5</title>
    <url>/p/10010/</url>
    <content><![CDATA[<p>在此，记录一下，唯一一个成功的方法：</p>
<ol>
<li><p>首先下载好win10的ios镜像文件，这个就是用于安装系统的（不懂的可以去搜索怎么安装win10系统）。</p>
<p>这是网址：<a href="https://www.microsoft.com/zh-cn/software-download/windows10ISO">https://www.microsoft.com/zh-cn/software-download/windows10ISO</a></p>
</li>
<li><p>右键点击win10原版镜像，依次选择 打开方式-windows资源管理器 ，记录出现的盘符，以便于后面的操作。</p>
<p>其中 G、H、I盘是我的一U盘的三个分区，本来win10原版镜像是在我的G盘中。</p>
</li>
</ol>
<p>   <img src="/p/10010/image-20200413200026262.png" alt="image-20200413200026262"></p>
<ol start="3">
<li><p>以管理员身份运行命令提示符，输入以下命令行：<br>“*<strong>dism.exe /online /enable-feature /featurename:netfx3 /Source:E:\sources\sxs*</strong>”<br>或者输入：“*<strong>Dism.exe /online /enable-feature /featurename:NetFX3/all /Source:E:/sources/sxs /LimitAccess*</strong>”</p>
<p>我把E盘改成I盘就可以了</p>
</li>
</ol>
<p><img src="/p/10010/image-20200413195237962.png" alt="image-20200413195237962"></p>
<p><strong>困扰已久的问题终于解决了！！</strong></p>]]></content>
      <categories>
        <category>软件安装</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>.Net</tag>
      </tags>
  </entry>
  <entry>
    <title>【NLP】自然语言处理 完整流程</title>
    <url>/p/10004/</url>
    <content><![CDATA[<h3 id="1-已有语料"><a href="#1-已有语料" class="headerlink" title="1. 已有语料"></a>1. 已有语料</h3><p>纸质或者电子文本资料—&gt;电子化—&gt;语料库。</p>
<h3 id="2-网上下载、抓取语料"><a href="#2-网上下载、抓取语料" class="headerlink" title="2. 网上下载、抓取语料"></a>2. 网上下载、抓取语料</h3><p>国内外标准开放数据集（比如国内的中文汉语有搜狗语料、人民日报语料） 或 通过爬虫。</p>
<h2 id="第二步：语料预处理"><a href="#第二步：语料预处理" class="headerlink" title="第二步：语料预处理"></a>第二步：语料预处理</h2><p>语料预处理大概会占到整个50%-70%的工作量。</p>
<p>基本过程： 数据清洗—&gt;分词—&gt;词性标注—&gt;去停词</p>
<h3 id="1-语料清洗"><a href="#1-语料清洗" class="headerlink" title="1. 语料清洗"></a>1. 语料清洗</h3><p>语料清洗：在语料中找到感兴趣的内容，将不感兴趣、视为噪音的内容清洗删除。包括：对于原始文本提取标题、摘要、正文等信息，对于爬虫，去除广告、标签、HTML、JS等代码和注释。</p>
<p>常见数据清洗方式：人工去重、对齐、删除和标注等，或规则提取内容、正则表达式匹配、根据词性和命名实体提取，编写脚本或代码批处理等。</p>
<h3 id="2-分词"><a href="#2-分词" class="headerlink" title="2. 分词"></a>2. 分词</h3><p><strong>分词</strong>：将短文本和长文本处理为最小单位粒度是词或词语的过程。</p>
<p><strong>常见方法</strong>：基于字符串匹配的分词方法、基于理解的分词方法、基于统计的分词方法和基于规则的分词方法，其中每种方法下面对应许多具体的方法。</p>
<p><strong>难点</strong>：歧义识别 和 新词识别。 eg：“羽毛球拍卖完了”，这个可以切分成“羽毛 球拍 卖 完 了”，也可切分成“羽毛球 拍卖 完 了”—&gt;上下文信息</p>
<h3 id="3-词性标注"><a href="#3-词性标注" class="headerlink" title="3. 词性标注"></a>3. 词性标注</h3><p><strong>词性标注</strong>：对每个词或词语打词类标签，是一个经典的序列标注问题。eg：形容词、动词、名词等。有助于在后面的处理中融入更多有用的语言信息。</p>
<p><strong>词性标注不是非必需的。</strong>比如，常见的文本分类就不用关心词性问题，但是类似情感分析、知识推理却是需要的，下图是常见的中文词性整理。</p>
<p><img src="/p/10004/20190306172401951.png" alt="词性编码"></p>
<p><strong>常见方法</strong>：基于规则和基于统计的方法。</p>
<ul>
<li>基于统计的方法：基于最大熵的词性标注、基于统计最大概率输出词性、基于 HMM、CRF+BiLSTM 的词性标注。</li>
</ul>
<h3 id="4-去停用词"><a href="#4-去停用词" class="headerlink" title="4. 去停用词"></a>4. 去停用词</h3><p>  <strong>停用词</strong>：对文本特征没有任何贡献的字词，eg：标点符号、语气、人称等。</p>
<p>  <strong>注意：根据具体场景决定</strong>。eg：在情感分析中，语气词、感叹号是应该保留的，因为他们对表示语气程度、感情色彩有一定的贡献和意义。</p>
<h2 id="第三步：特征工程"><a href="#第三步：特征工程" class="headerlink" title="第三步：特征工程"></a>第三步：特征工程</h2><p>如何把分词之后的字和词语表示成计算机能够计算的类型。</p>
<p><strong>思路</strong>：中文分词的字符串—&gt; 向量</p>
<p>两种常用表示模型：</p>
<blockquote>
<ol>
<li><p>词袋模型（BoW）<br>词袋模型（Bag of Word, BOW)：不考虑词语原本在句子中的顺序，直接将每一个词语或者符号统一放置在一个集合（如 list），然后按照计数的方式对出现的次数进行统计。统计词频这只是最基本的方式，TF-IDF 是词袋模型的一个经典用法。</p>
</li>
<li><p>词向量<br>词向量：将字、词语转换为向量矩阵的计算模型。</p>
<p>常用的词表示方法：</p>
<ul>
<li><p>One-Hot：把每个词表示为一个很长的向量。这个向量的维度是词表大小，其中绝大多数元素为 0，只有一个维度的值为 1，这个维度就代表了当前的词。eg: [0 0 0 0 0 0 0 0 1 0 0 0 0 … 0]</p>
</li>
<li><p>Word2Vec：其主要包含两个模型：跳字模型（Skip-Gram）和连续词袋模型（Continuous Bag of Words，简称 CBOW），以及两种高效训练的方法：负采样（Negative Sampling）和层序 Softmax（Hierarchical Softmax）。值得一提的是，Word2Vec 词向量可以较好地表达不同词之间的相似和类比关系。</p>
</li>
<li><p>Doc2Vec</p>
</li>
<li><p>WordRank</p>
</li>
<li><p>FastText</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="第四步：特征选择"><a href="#第四步：特征选择" class="headerlink" title="第四步：特征选择"></a>第四步：特征选择</h2><p> <strong>关键</strong>：如何构造好的特征向量？—&gt; 要选择合适的、表达能力强的特征。</p>
<p><strong>常见的特征选择方法：DF、 MI、 IG、 CHI、WLLR、WFO 六种。</strong></p>
<h2 id="第五步：模型训练"><a href="#第五步：模型训练" class="headerlink" title="第五步：模型训练"></a>第五步：模型训练</h2><h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h3><p>对于不同的应用需求，我们使用不同的模型</p>
<ul>
<li><p>传统的有监督和无监督等机器学习模型： KNN、SVM、Naive Bayes、决策树、GBDT、K-means 等模型；</p>
</li>
<li><p>深度学习模型： CNN、RNN、LSTM、 Seq2Seq、FastText、TextCNN 等。</p>
</li>
</ul>
<h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h3><h4 id="（1）过拟合"><a href="#（1）过拟合" class="headerlink" title="（1）过拟合"></a>（1）过拟合</h4><p>  <strong>过拟合</strong>：模型学习能力太强，以至于把噪声数据的特征也学习到了，导致模型泛化能力下降，在训练集上表现很好，但是在测试集上表现很差。</p>
<p>常见的解决方法有：</p>
<ul>
<li><p>增大数据的训练量；</p>
</li>
<li><p>增加正则化项，如 L1 正则和 L2 正则；</p>
</li>
<li><p>特征选取不合理，人工筛选特征和使用特征选择算法；</p>
</li>
<li><p>采用 Dropout 方法等。</p>
</li>
</ul>
<h4 id="（2）欠拟合"><a href="#（2）欠拟合" class="headerlink" title="（2）欠拟合"></a>（2）欠拟合</h4><p>  <strong>欠拟合</strong>：就是模型不能够很好地拟合数据，表现在模型过于简单。</p>
<p>常见的解决方法有：</p>
<ul>
<li>添加其他特征项；</li>
<li>增加模型复杂度，比如神经网络加更多的层、线性模型通过添加多项式使模型泛化能力更强；</li>
<li>减少正则化参数，正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。<h4 id="（3）对于神经网络，注意梯度消失和梯度爆炸问题。"><a href="#（3）对于神经网络，注意梯度消失和梯度爆炸问题。" class="headerlink" title="（3）对于神经网络，注意梯度消失和梯度爆炸问题。"></a>（3）对于神经网络，注意梯度消失和梯度爆炸问题。</h4></li>
</ul>]]></content>
      <categories>
        <category>NLP</category>
      </categories>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>生有涯而知无涯</title>
    <url>/p/10000/</url>
    <content><![CDATA[<p>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在无限序列中随机抽取元素</title>
    <url>/p/10012/</url>
    <content><![CDATA[<p><strong>问题：在一个无限的整数数据流，如何从中等概率随机抽取 k 个整数出来？</strong></p>
<p><strong>先解决只抽取一个元素的问题</strong>，这个问题的难点在于，随机选择是**<code>动态</code><strong>的，比如说目前数据流中只有五个元素，你从当前</strong><code>静态</code><strong>的数据流中随机选择了一个数据<code>a</code>作为结果（从固定的五个数据中随机抽一个，当然每个数据被抽取到的概率都是1/5），但是，在抽取完后，此时数据流中又新加入了一个元素 <code>b</code>（这就是</strong><code>动态</code>**数据流了），你应该留着 <code>a</code> 还是将 <code>b</code> 作为结果呢，以什么逻辑选择 <code>a</code> 和 <code>b</code> 呢，怎么证明你的选择方法在概率上是公平的呢？（也就是六个数据等概率抽取是1/6，而元素a是以1/5的概率抽取到的，怎么把a的最终概率调整为1/6？）</p>
<p><strong>先说结论，当你遇到第</strong> <strong><code>i</code></strong> <strong>个元素时，应该有</strong> <strong><code>1/i</code></strong> <strong>的概率选择该元素，</strong><code>1 - 1/i</code> <strong>的概率保持原有的选择</strong>。看代码容易理解这个思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回链表中一个随机节点的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">    ListNode p = head;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="comment">// 这个整数等于 0 的概率就是 1/i</span></span><br><span class="line">        <span class="keyword">if</span> (r.nextInt(++i) == <span class="number">0</span>) &#123;</span><br><span class="line">            res = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>证明</strong>：假设总共有 n 个元素，我们要的随机性就是每个元素被选择的概率都是 1/n ，那么对于第 i 个元素，它被选择的概率就是：<br>$$<br>\begin{aligned}<br>&amp; \frac{1}{i} \times\left(1-\frac{1}{i+1}\right) \times\left(1-\frac{1}{i+2}\right) \times \ldots \times\left(1-\frac{1}{n}\right) \<br>=&amp; \frac{1}{i} \times \frac{i}{i+1} \times \frac{i+1}{i+2} \times \ldots \times \frac{n-1}{n} \<br>=&amp; \frac{1}{n}<br>\end{aligned}<br>$$</p>
<p>第 <code>i</code> 个元素被选择的概率是 <code>1/i</code>，第 <code>i+1</code> 次不被替换的概率是 <code>1 - 1/(i+1)</code>，以此类推，相乘就是第 <code>i</code> 个元素最终被选中的概率，就是 <code>1/n</code>。</p>
<p>还是上面那个例子：b是第六个元素，那么以1/6的概率选择b，丢弃a（那最终概率就是1/6），以1-1/6的概率不选择b，保留原有的结果a（那么最终概率就是$\frac{1}{5}\times \frac{5}{6}=\frac{1}{6}$）</p>
<p>因此，该算法的逻辑是正确的。</p>
<p><strong>同理，如果要随机选择</strong> <strong><code>k</code></strong> <strong>个数，只要在第</strong> <strong><code>i</code></strong> <strong>个元素处以</strong> <strong><code>k/i</code></strong> <strong>的概率选择该元素，以</strong> <strong><code>1 - k/i</code></strong> <strong>的概率保持原有选择即可</strong>。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 返回链表中 k 个随机节点的值 */</span></span><br><span class="line"><span class="keyword">int</span>[] getRandom(ListNode head, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    ListNode p = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前 k 个元素先默认选上</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k &amp;&amp; p != <span class="keyword">null</span>; j++) &#123;</span><br><span class="line">        res[j] = p.val;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = k;</span><br><span class="line">    <span class="comment">// while 循环遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 生成一个 [0, i) 之间的整数</span></span><br><span class="line">        <span class="keyword">int</span> j = r.nextInt(++i);</span><br><span class="line">        <span class="comment">// 这个整数小于 k 的概率就是 k/i</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">            res[j] = p.val;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于数学证明，和上面区别不大：<br>$$<br>\begin{aligned}<br>&amp; \frac{k}{i} \times\left(1-\frac{k}{i+1} \times \frac{1}{k}\right) \times\left(1-\frac{k}{i+2} \times \frac{1}{k}\right) \times \ldots \times\left(1-\frac{k}{n} \times \frac{1}{k}\right) \<br>=&amp; \frac{k}{i} \times\left(1-\frac{1}{i+1}\right) \times\left(1-\frac{1}{i+2}\right) \times \ldots \times\left(1-\frac{1}{n}\right) \<br>=&amp; \frac{k}{i} \times \frac{i}{i+1} \times \frac{i+1}{i+2} \times \ldots \times \frac{n-1}{n} \<br>=&amp; \frac{k}{n}<br>\end{aligned}<br>$$<br>因为虽然每次更新选择的概率增大了 <code>k</code> 倍，但是选到具体第 <code>i</code> 个元素的概率还是要乘 <code>1/k</code>，也就回到了上一个推导。</p>
]]></content>
      <categories>
        <category>蓄水池抽样</category>
        <category>数据流采样</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>安装bert-base==0.0.9及配置环境</title>
    <url>/p/10013/</url>
    <content><![CDATA[<p><code>先说结论：bert-base 0.0.9 |  tensorflow 1.15.2 | numpy 1.16.4</code></p>
<p>我是按照这篇博客安装bert-base-ner：<a href="https://blog.csdn.net/macanv/article/details/85684284">https://blog.csdn.net/macanv/article/details/85684284</a></p>
<p>不过这篇安装的是bert-base==0.0.7，而且也没有说明对应的tensorflow是哪个版本的。</p>
<p>于是，我直接安装了最新的bert-base==0.0.9版本</p>
<p>然后 pip install tensorflow ，太慢了，我直接去镜像源下载whl文件进行安装：<a href="https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/">https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/tensorflow/</a></p>
<p>先选用了tensorflow==2.0.0版本，出现报错，说setuptools版本不对，行吧，卸载重装setuptools，结果出现这个报错：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">Cannot remove entries from nonexistent file c:<span class="symbol">\p</span>rogramdata<span class="symbol">\a</span>naconda3<span class="symbol">\e</span>nvs<span class="symbol">\p</span>y37<span class="symbol">\l</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>asy-install.pth</span><br></pre></td></tr></table></figure>
<p>最后找到办法：</p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line"># windows 用：</span><br><span class="line">echo test&gt;c:<span class="symbol">\p</span>rogramdata<span class="symbol">\a</span>naconda3<span class="symbol">\e</span>nvs<span class="symbol">\p</span>y37<span class="symbol">\l</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>asy-install.pth</span><br><span class="line"># linux 用：</span><br><span class="line">touch c:<span class="symbol">\p</span>rogramdata<span class="symbol">\a</span>naconda3<span class="symbol">\e</span>nvs<span class="symbol">\p</span>y37<span class="symbol">\l</span>ib<span class="symbol">\s</span>ite-packages<span class="symbol">\e</span>asy-install.pth</span><br></pre></td></tr></table></figure>
<p>然后就可以顺利卸载并安装setuptools最新版本了（46.x.x）了</p>
<p>然后tensorflow==2.0.0安装成功，结果运行bert-base-ner-train -help又报错，好吧，是tensorflow版本太高的原因。</p>
<p>卸载掉2.0.0，我重装tensorflow==1.15.2，可以用，但是会出现警告，去警告的文件改下就行了。</p>
<p>另外，numpy版本可能出现问题（我原本的是1.18.x，高了）,卸载numpy，重新安装numpy==1.16.4</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">(py37) &gt; bert-base-ner-train -help</span><br><span class="line">usage: bert-base-ner-train [-h] [-data_dir <span class="symbol">DATA_DIR</span>]</span><br><span class="line">                           [-bert_config_file <span class="symbol">BERT_CONFIG_FILE</span>]</span><br><span class="line">                           [-output_dir <span class="symbol">OUTPUT_DIR</span>]</span><br><span class="line">                           [-init_checkpoint <span class="symbol">INIT_CHECKPOINT</span>]</span><br><span class="line">                           [-vocab_file <span class="symbol">VOCAB_FILE</span>]</span><br><span class="line">                           [-max_seq_length <span class="symbol">MAX_SEQ_LENGTH</span>]</span><br><span class="line">                           [-do_train <span class="symbol">DO_TRAIN</span>] [-do_eval <span class="symbol">DO_EVAL</span>]</span><br><span class="line">                           [-do_predict <span class="symbol">DO_PREDICT</span>] [-batch_size <span class="symbol">BATCH_SIZE</span>]</span><br><span class="line">                           [-learning_rate <span class="symbol">LEARNING_RATE</span>]</span><br><span class="line">                           [-num_train_epochs <span class="symbol">NUM_TRAIN_EPOCHS</span>]</span><br><span class="line">                           [-dropout_rate <span class="symbol">DROPOUT_RATE</span>] [-clip <span class="symbol">CLIP</span>]</span><br><span class="line">                           [-warmup_proportion <span class="symbol">WARMUP_PROPORTION</span>]</span><br><span class="line">                           [-lstm_size <span class="symbol">LSTM_SIZE</span>] [-num_layers <span class="symbol">NUM_LAYERS</span>]</span><br><span class="line">                           [-cell <span class="symbol">CELL</span>]</span><br><span class="line">                           [-save_checkpoints_steps <span class="symbol">SAVE_CHECKPOINTS_STEPS</span>]</span><br><span class="line">                           [-save_summary_steps <span class="symbol">SAVE_SUMMARY_STEPS</span>]</span><br><span class="line">                           [-filter_adam_var <span class="symbol">FILTER_ADAM_VAR</span>]</span><br><span class="line">                           [-do_lower_case <span class="symbol">DO_LOWER_CASE</span>] [-clean <span class="symbol">CLEAN</span>]</span><br><span class="line">                           [-device_map <span class="symbol">DEVICE_MAP</span>] [-label_list <span class="symbol">LABEL_LIST</span>]</span><br><span class="line">                           [-verbose] [-ner <span class="symbol">NER</span>] [-version]</span><br><span class="line">bert-base-ner-train: error: argument -h/--help: ignored explicit argument <span class="string">&#x27;elp&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​                                                               <strong>完美</strong></p>
]]></content>
      <categories>
        <category>Bert</category>
        <category>tensorflow</category>
        <category>numpy</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>《神经网络与机器学习》笔记（一）</title>
    <url>/p/10014/</url>
    <content><![CDATA[<h1 id="《神经网络与深度学习》笔记"><a href="#《神经网络与深度学习》笔记" class="headerlink" title="《神经网络与深度学习》笔记"></a>《神经网络与深度学习》笔记</h1><p><img src="https://upload-images.jianshu.io/upload_images/16788405-92f59abf85a514b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本书组织架构"></p>
<p>​                                         </p>
<h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><hr>
<h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章  绪论"></a>第一章  绪论</h3><h4 id="特征表示方法"><a href="#特征表示方法" class="headerlink" title="特征表示方法"></a>特征表示方法</h4><p><strong>局部特征</strong></p>
<blockquote>
<p>含义：也称为<em>离散表示</em>或<em>符号表示</em>，通常是用one-hot向量的形式</p>
<p>优点：</p>
<ol>
<li>这种离散的表示方式具有很好的解释性</li>
<li>因为向量稀疏，所以用于线性模型时计算效率非常高</li>
</ol>
<p>缺点：</p>
<ol>
<li>one-hot向量维数太高，不能扩展（因为维数是由词表大小决定的）</li>
<li>不同向量之间的相似度为0，无法进行相似度计算</li>
</ol>
</blockquote>
<p><strong>分布式表示</strong></p>
<blockquote>
<p>含义：也称为*分散式表示，如NLP中的词嵌入，是用语义空间的基向量进行表示的</p>
<p>优点：</p>
<ol>
<li>可以表示成低维的稠密向量</li>
<li>表示能力强，维数可以指定</li>
<li>相似度容易计算</li>
</ol>
<p>缺点：</p>
<ol>
<li>解释性不强</li>
</ol>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/16788405-cf9da67b4d70e5b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="深度学习需要解释的问题是：贡献度分配问题
"></p>
<p>​                                                      </p>
<h3 id="第二章-机器学习概述"><a href="#第二章-机器学习概述" class="headerlink" title="第二章  机器学习概述"></a>第二章  机器学习概述</h3><p><strong>损失函数</strong></p>
<blockquote>
<p>$$<br>\begin{aligned} \mathcal{L}(y, f(x ; \theta)) &amp;=\left{\begin{array}{ll}{0} &amp; {\text { if } y=f(x ; \theta)} \ {1} &amp; {\text { if } y \neq f(x ; \theta)}\end{array}\right.\ &amp;=I(y \neq f(x ; \theta)) \end{aligned}\<br>0-1损失函数，能够客观的评价模型好坏，但数学性质不好，不连续且导数部位0，难以优化。<br>$$</p>
</blockquote>
<blockquote>
<p>$$<br>平方损失函数：\mathcal{L}(y, f(x ; \theta))=\frac{1}{2}(y-f(x ; \theta))^{2}\<br>经常用在预测标签y 为实数值的任务中，平方损失函数一般不适用于分类问题。因为输入和输出不为连续值。<br>$$</p>
</blockquote>
<blockquote>
<p>$$<br>交叉熵损失函数：一般用于分类问题（衡量两个概率分布的差异：即标签真实分布y和模型预测分布f(x;\theta)之间的交叉熵）\<br>\mathcal{L}(\boldsymbol{y}, f(\boldsymbol{x} ; \theta))=-\sum_{c=1}^{C} y_{c} \log f_{c}(\boldsymbol{x} ; \theta)\<br>由上公式可知，交叉熵损失函数也就是 负对数似然损失函数<br>$$</p>
</blockquote>
<blockquote>
<p>$$<br>Hinge损失函数：在二分类问题中，假设y的取值为{-1，+1}，f(x;\theta)\in\mathbb{R}:\<br>\begin{aligned} \mathcal{L}(y, f(x ; \theta)) &amp;=\max (0,1-y f(x ; \theta)) \ &amp; \triangleq[1-y f(x ; \theta)]<em>{+} \end{aligned}    \<br>其中[x]</em>+=max(0,x)<br>$$</p>
</blockquote>
<p><strong>优化方法</strong></p>
<blockquote>
<p>批量梯度下降算法：计算量太大</p>
<p>随机梯度下降算法：无法利用计算机的并行性</p>
<p>小批量梯度下降法：前两者的折中，是目前最主要的优化算法</p>
</blockquote>
<p><strong>参数学习</strong></p>
<blockquote>
<p>机器学习任务可以分为两类： 一类是样本的特征向量x 和标签y 之间存在未知的函数关系y = h(x)，另一类是条件概率p(y|x) 服从某个未知分布。最小二乘法是属于第一类，直接建模x 和标签y 之间的函数关系。此外，线性回归还可以通过建模条件概率p(y|x) 的角度来进行参数估计。</p>
</blockquote>
<p>经验风险最小化</p>
<blockquote>
<p>可以用平方损失函数来计算：<br>$$<br>\begin{aligned} \mathcal{R}(\boldsymbol{w}) &amp;=\sum_{n=1}^{N} \mathcal{L}\left(y^{(n)}, f\left(\boldsymbol{x}^{(n)} ; \boldsymbol{w}\right)\right) \ &amp;=\frac{1}{2} \sum_{n=1}^{N}\left(y^{(n)}-\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}^{(n)}\right)^{2} \ &amp;=\frac{1}{2}\left|\boldsymbol{y}-X^{\mathrm{T}} \boldsymbol{w}\right|^{2} \end{aligned}\<br>用最小二乘法求得最优参数：\begin{aligned} w^{*} &amp;=\left(X X^{\mathrm{T}}\right)^{-1} X y &amp;=\left(\sum_{n=1}^{N}x^{(n)}\left(x^{(n)}\right)^{\mathrm{T}}\right)^{-1}\left(\sum_{n=1}^{N} x^{(n)} y^{(n)}\right) \end{aligned}\<br>用最小二乘法进行计算有个限制:XX^T必须存在逆矩阵，也就是说X中得行向量必须是线性无关的。\<br>当XX^T不可逆时，有两种方法：1)使用主成分分析等方法先预处理数据，消除特征间的相关性，再用最小二乘法。\<br>2)通过梯度下降法来估计参数，然后用最小均方(LMS)法:w \leftarrow w+\alpha X\left(y-X^{\mathrm{T}} w\right)<br>$$</p>
</blockquote>
<p>结构风险最小化</p>
<blockquote>
<p>为了解决最小二乘法中，因为特征间的多重共线性而导致计算不准确的问题，出现了岭回归，即给XX^T^的对角线元素都加上一个常数λ使得（XX^T^+λI）满秩。从而最优参数$$w^*=(XX^T+\lambda I)^{-1}X y$$.</p>
<p>岭回归可以看作是结构风险最小化准则下的最小二乘法估计。且其目标函数可以写为：<br>$$<br>\mathcal{R}(\boldsymbol{w})=\frac{1}{2}\left|\boldsymbol{y}-X^{\mathrm{T}} \boldsymbol{w}\right|^{2}+\frac{1}{2} \lambda|\boldsymbol{w}|^{2}<br>$$</p>
</blockquote>
<h3 id="第三章-线性模型"><a href="#第三章-线性模型" class="headerlink" title="第三章 线性模型"></a>第三章 线性模型</h3><p>四种不同的线性分类模型：Logistic回归、Softmax回归、感知机和支持向量机</p>
<h4 id="线性判别函数和决策边界"><a href="#线性判别函数和决策边界" class="headerlink" title="线性判别函数和决策边界"></a>线性判别函数和决策边界</h4><blockquote>
<p>最简单的是二分类：只需要一个线性判别函数：$$f(x;w)=w^Tx+b$$。决策边界就是特征空间$$\mathbb{R}^{d}$$中所有满足$$f(x;w)=0$$的点组成的一个分割超平面。</p>
<p>多分类：是指分类的类别数C大于2。设计多分类的判别函数有三种常用方法：</p>
<ol>
<li><p>“一对其余”方式，也就是转化成C个“一对其余”的二分类问题，这需要C个判别函数。</p>
</li>
<li><p>“一对一”方式，就是转化成C(C-1)/2个“一对一的”二分类问题。。这种方式共需要C(C − 1)/2 个判别函数，其中第(i, j) 个判别函数是把类别 i 和类别 j 的样本分开。</p>
</li>
<li><p>“argmax”方式：是一种改进的“一对其余”方式，需要C个判别函数：</p>
<p>$$f_c(x;w_c)=w^T_cx+b_c,    c=[1,\dots,C]$$，对于样本x，如果存在一个类别c，相对于所有的其他类别˜c(˜c≠ c) 有f<del>c</del>(x;w<del>c</del>) &gt; f<del>˜c</del>(x,w<del>˜c</del>)，那么x 属于类别c。“argmax”方式的预测函数定义为:</p>
<p>$$y=argmax^C_{c=1}f_c(x;w_c)$$</p>
</li>
</ol>
<p>“一对其余”方式和“一对一”方式都存在一个缺陷：特征空间中会存在一些 难以确定类别的区域，而“argmax”方式很好地解决了这个问题：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/16788405-5ebc8d85449e6e4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
</blockquote>
<h4 id="Logistic-回归"><a href="#Logistic-回归" class="headerlink" title="Logistic 回归"></a>Logistic 回归</h4><p>是一种常用的处理二分类问题的线性模型。</p>
<p>为了解决连续的线性函数不适合进行分类的问题，我们引入非线性函数$$g:\mathbb{R}^d\rightarrow(0,1)$$来预测类别标签的后验概率p(y = 1|x)。$$p(y=1|x)=g(f(x;w))$$。</p>
<p>其中$$g(\cdot)$$通常被称为激活函数，其作用是把线性函数的值域从实数“挤压”到(0,1)之间，可以用来表示概率。。在统计文献中，g(·) 的逆函数g^−1^(·) 也称为联系函数（Link Function）。</p>
<p>在Logistic 回归中，激活函数就是Logistic 函数，标签y=1的后验概率为：$$p(y=1|x)=\sigma\left(\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}\right)\triangleq \frac{1}{1+\exp \left(-\boldsymbol{w}^{\mathrm{T}} \boldsymbol{x}\right)}$$。</p>
<p>Logistic 回归采用交叉熵作为损失函数：  </p>
<p>$$\mathcal{R}(w)=-\frac{1}{N} \sum_{n=1}^{N}\left(p_{r}\left(y^{(n)}=1 | x^{(n)}\right) \log \hat{y}^{(n)}+p_{r}\left(y^{(n)}=0 | x^{(n)}\right) \log \left(1-\hat{y}^{(n)}\right)\right)\=-\frac{1}{N} \sum_{n=1}^{N}\left(y^{(n)} \log \hat{y}^{(n)}+\left(1-y^{(n)}\right) \log \left(1-\hat{y}^{(n)}\right)\right)$$</p>
<p>采用梯度下降法来对参数进行优化：$$\boldsymbol{w}<em>{t+1} \leftarrow \boldsymbol{w}</em>{t}+\alpha \frac{1}{N} \sum_{n=1}^{N} \boldsymbol{x}^{(n)}\left(y^{(n)}-\hat{y}<em>{\boldsymbol{w}</em>{t}}^{(n)}\right)$$</p>
<h4 id="Softmax-回归"><a href="#Softmax-回归" class="headerlink" title="Softmax 回归"></a>Softmax 回归</h4><p>也称为多项或多类的Logistic 回归，是Logistic 回归在多分类问题上的推广。</p>
<p>对于多类问题，类别标签y ∈ {1, 2, · · · ,C}可以有C个取值。y是用one-hot向量表示的，给定一个样本x，Softmax 回归预测的属于类别c 的条件概率为：<br>$$<br>\begin{aligned} p(y=c | \boldsymbol{x}) &amp;=\operatorname{softmax}\left(\boldsymbol{w}<em>{c}^{\mathrm{T}} \boldsymbol{x}\right) \ &amp;=\frac{\exp \left(\boldsymbol{w}</em>{c}^{\mathrm{T}} \boldsymbol{x}\right)}{\sum_{c^{\prime}=1}^{C} \exp \left(\boldsymbol{w}<em>{c^{\prime}}^{\mathrm{T}} \boldsymbol{x}\right)} \end{aligned}<br>$$<br>其中w<del>c</del>是第c类的权重向量。上述公式向量表示为：<br>$$<br>\begin{aligned} \hat{\boldsymbol{y}} &amp;=\operatorname{softmax}\left(W^{\mathrm{T}} \boldsymbol{x}\right) =\frac{\exp \left(W^{\mathrm{T}} \boldsymbol{x}\right)}{1^{\mathrm{T}} \exp \left(W^{\mathrm{T}} \boldsymbol{x}\right)} \end{aligned}   ，1为全1向量<br>$$<br>Softmax 回归的决策函数可以表示为：<br>$$<br>\begin{aligned} \hat{y} &amp;=\underset{c=1}{\arg \max } p(y=c | \boldsymbol{x}) \ &amp;=\underset{c=1}{\arg \max } \boldsymbol{w}</em>{c}^{\mathrm{T}} \boldsymbol{x} \end{aligned}<br>$$<br>与Logistic 回归的关系：当类别数C = 2 时，Softmax 回归的决策函数为：<br>$$<br>\begin{aligned} \hat{y} &amp;=\underset{y \in{0,1}}{\arg \max } \boldsymbol{w}<em>{y}^{\mathrm{T}} \boldsymbol{x} \ &amp;=I\left(\boldsymbol{w}</em>{1}^{\mathrm{T}} \boldsymbol{x}-\boldsymbol{w}<em>{0}^{\mathrm{T}} \boldsymbol{x}&gt;0\right) =I\left(\left(\boldsymbol{w}</em>{1}-\boldsymbol{w}_{0}\right)^{\mathrm{T}} \boldsymbol{x}&gt;0\right) \end{aligned}<br>$$<br>二分类中的权重向量$$w=w_1-w_0$$</p>
<p>Softmax 回归也采用交叉熵损失函数，其风险函数为：<br>$$<br>\begin{aligned} \mathcal{R}(W) &amp;=-\frac{1}{N} \sum_{n=1}^{N} \sum_{c=1}^{C} \boldsymbol{y}<em>{c}^{(n)} \log \hat{\boldsymbol{y}}</em>{c}^{(n)} =-\frac{1}{N} \sum_{n=1}^{N}\left(\boldsymbol{y}^{(n)}\right)^{\mathrm{T}} \log \hat{\boldsymbol{y}}^{(n)} \end{aligned}\其中\hat{y}^{(n)} = softmax(W^Tx^{(n)}) 为样本x^{(n)} 在每个类别的后验概率<br>$$<br>风险函数$$ \mathcal{R}(W)  关于W 的梯度为<br>\frac{\partial \mathcal{R}(W)}{\partial W}=-\frac{1}{N} \sum_{n=1}^{N} x^{(n)}\left(\boldsymbol{y}^{(n)}-\hat{\boldsymbol{y}}^{(n)}\right)^{\mathrm{T}}$$<br>$$<br>采用梯度下降法，Softmax 回归的训练过程为：初始化W<del>0</del> ← 0，然后通过下式进行迭代更新：\<br>W_{t+1} \leftarrow W_{t}+\alpha\left(\frac{1}{N} \sum_{n=1}^{N} x^{(n)}\left(y^{(n)}-\hat{y}<em>{W</em>{t}}^{(n)}\right)^{\mathrm{T}}\right)<br>$$</p>
<h4 id="感知器"><a href="#感知器" class="headerlink" title="感知器"></a>感知器</h4><p>是一种线性分类器，也是最简单的人工神经网络</p>
<p>感知器的学习算法是一种错误驱动的在线学习算法。先初始化一个权重向量$$w\leftarrow0$$（通常是全零向量），然后每次分错一个样本(x, y)时，即$$yw^Tx&lt;0$$，就用这个样本来更新权重,采用随机梯度下降。$$w\leftarrow w+yx$$</p>
<p>但是感知器的权重更新与样本的顺序有关，只要每次迭代的顺序不一致时，找到的分割超平面也往往不一致。同时，如果训练集不是线性可分的，就永远不会收敛。</p>
<p>为解决对样本顺序的依赖问题，提出了参数平均感知器。</p>
<p>同时，将感知器在多分类上进行扩展，可以得到广义感知器。</p>
<h4 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h4><p>参照《西瓜书》</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://upload-images.jianshu.io/upload_images/16788405-e5d2f2987df593e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
</search>
