<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TuRuwei&#39;s Blog</title>
  
  <subtitle>爱学习，爱生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.turuwei.com/"/>
  <updated>2020-01-10T08:58:15.300Z</updated>
  <id>http://www.turuwei.com/</id>
  
  <author>
    <name>tmooming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitalk配置问题</title>
    <link href="http://www.turuwei.com/p/10007/"/>
    <id>http://www.turuwei.com/p/10007/</id>
    <published>2020-01-10T08:47:39.000Z</published>
    <updated>2020-01-10T08:58:15.300Z</updated>
    
    <content type="html"><![CDATA[<p>今天跟着网上给自己的博客配置gitalk评论功能，在配置完成后怎么都不对，看网页中控制台的报错信息是Container not found, document.getElementById: ${container} 这个报错信息，</p><p>然后搜教程说可能是 comments.swig 文件里面的代码贴错位置了，但我就是跟着教程做的，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  正确示例</span></span><br><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"comments"</span> id=<span class="string">"comments"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#123;% elseif theme.gitalk.enable %&#125;            <span class="comment">//  将复制的两行代码贴在这个位置</span></span><br><span class="line">    &lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//  错误示例</span></span><br><span class="line">&#123;% elseif theme.valine.appid and theme.valine.appkey %&#125;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"comments"</span> id=<span class="string">"comments"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>  </span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line"> </span><br><span class="line">&#123;% elseif theme.gitalk.enable %&#125;</span><br><span class="line">&lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>我之前写的就是正确示例这样，就是怎么都不显示，然后我干脆改成<strong>错误示例</strong>的样子，结果就出来了！！！！我觉得就是elif的逻辑判断问题，不能嵌套。</p><p>另外，在第一次配置后，可能会在评论区显示，没有相关issue，请联系xxx。这个就需要自己想在博客中登录github账号，就能正常显示了。</p><p>完美~</p>]]></content>
    
    <summary type="html">
    
      comments.swig中插入问题
    
    </summary>
    
    
      <category term="Bug" scheme="http://www.turuwei.com/categories/Bug/"/>
    
    
      <category term="gitalk" scheme="http://www.turuwei.com/tags/gitalk/"/>
    
      <category term="next" scheme="http://www.turuwei.com/tags/next/"/>
    
      <category term="hexo" scheme="http://www.turuwei.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Dataframe拼接操作报错</title>
    <link href="http://www.turuwei.com/p/10006/"/>
    <id>http://www.turuwei.com/p/10006/</id>
    <published>2020-01-09T13:25:36.000Z</published>
    <updated>2020-01-09T13:37:29.292Z</updated>
    
    <content type="html"><![CDATA[<p>今天在优化一个程序时遇到的问题，记录一下。</p><p>这是一个对csv文件中的字段导入为Dataframe格式，然后计算相似度的程序，因为数据量很大，需要两个小时才能跑完，所以决定进行并行化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> mp</span><br><span class="line">num = mp.cpu_count()<span class="number">-1</span></span><br><span class="line">    pool = mp.Pool(processes=num)</span><br><span class="line">    df_split = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(df), len(df)//num):</span><br><span class="line">        <span class="comment"># 原本写的</span></span><br><span class="line">        <span class="comment"># df_split.append(df.iloc[i:min(i + len(df)//num, len(df)),:])</span></span><br><span class="line">        <span class="comment"># 修改后</span></span><br><span class="line">        df_split.append(df.iloc[i:min(i + len(df)//num, len(df)),:].reset_index())</span><br><span class="line">    <span class="comment"># mllistBZ是自己写的方法，传入Dataframe格式，返回的也是Dataframe格式</span></span><br><span class="line">    df = pd.concat(pool.map(mllistBZ, df_split))</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    df.to_csv(<span class="string">'标准化.csv'</span>, index=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>在晚上找了资料，写完后运行就报错。最后排查发现是因为Dataframe在拆分后再合并，其下标就不对了，需要进行reset_index（）。否则就会报如下错误。不过，如果仅仅是打印出来，也是不会报错的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;multiprocessing&#x2F;pool.py&quot;, line 121, in worker</span><br><span class="line">    result &#x3D; (True, func(*args, **kwds))</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;multiprocessing&#x2F;pool.py&quot;, line 44, in mapstar</span><br><span class="line">    return list(map(*args))</span><br><span class="line">  File &quot;biaozhunhua.py&quot;, line 128, in mllistBZ</span><br><span class="line">    if document[&#39;其他&#39;][i] &#x3D;&#x3D; &#39;&#39; or document[&#39;其他&#39;][i] is np.nan:</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;pandas&#x2F;core&#x2F;series.py&quot;, line 868, in __getitem__</span><br><span class="line">    result &#x3D; self.index.get_value(self, key)</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;pandas&#x2F;core&#x2F;indexes&#x2F;base.py&quot;, line 4375, in get_value</span><br><span class="line">    tz&#x3D;getattr(series.dtype, &#39;tz&#39;, None))</span><br><span class="line">  File &quot;pandas&#x2F;_libs&#x2F;index.pyx&quot;, line 81, in pandas._libs.index.IndexEngine.get_value</span><br><span class="line">  File &quot;pandas&#x2F;_libs&#x2F;index.pyx&quot;, line 89, in pandas._libs.index.IndexEngine.get_value</span><br><span class="line">  File &quot;pandas&#x2F;_libs&#x2F;index.pyx&quot;, line 132, in pandas._libs.index.IndexEngine.get_loc</span><br><span class="line">  File &quot;pandas&#x2F;_libs&#x2F;hashtable_class_helper.pxi&quot;, line 987, in pandas._libs.hashtable.Int64HashTable.get_item</span><br><span class="line">  File &quot;pandas&#x2F;_libs&#x2F;hashtable_class_helper.pxi&quot;, line 993, in pandas._libs.hashtable.Int64HashTable.get_item</span><br><span class="line">KeyError: 0</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;biaozhunhua.py&quot;, line 195, in &lt;module&gt;</span><br><span class="line">    run(df)</span><br><span class="line">  File &quot;biaozhunhua.py&quot;, line 162, in run</span><br><span class="line">    df &#x3D; pd.concat(pool.map(mllistBZ, df_split))</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;multiprocessing&#x2F;pool.py&quot;, line 268, in map</span><br><span class="line">    return self._map_async(func, iterable, mapstar, chunksize).get()</span><br><span class="line">  File &quot;&#x2F;home&#x2F;turw&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;multiprocessing&#x2F;pool.py&quot;, line 657, in get</span><br><span class="line">    raise self._value</span><br><span class="line">KeyError: 0</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Dataframe在拆分后再合并，需要进行reset_index操作
    
    </summary>
    
    
      <category term="Python" scheme="http://www.turuwei.com/categories/Python/"/>
    
    
      <category term="pandas" scheme="http://www.turuwei.com/tags/pandas/"/>
    
      <category term="Dataframe" scheme="http://www.turuwei.com/tags/Dataframe/"/>
    
      <category term="并行" scheme="http://www.turuwei.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>no matching manifest for windows/amd64 10.0.18362 in the manifest list entri</title>
    <link href="http://www.turuwei.com/p/10005/"/>
    <id>http://www.turuwei.com/p/10005/</id>
    <published>2020-01-06T05:04:47.000Z</published>
    <updated>2020-01-06T05:11:03.889Z</updated>
    
    <content type="html"><![CDATA[<p>Windows下使用docker 下载镜像时 报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no matching manifest for windows&#x2F;amd64 10.0.18362 in the manifest list entri</span><br></pre></td></tr></table></figure><p>或者是另一种错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image operating system &quot;linux&quot; cannot be used on this platform</span><br></pre></td></tr></table></figure><p>都是同一种解决方案：设置daemon.json的experimental:true</p><p><img src="/p/10005/20200106010842.png" alt="Daemon设置"></p>]]></content>
    
    <summary type="html">
    
      docker配置错误导致Kitematic无法下载容器
    
    </summary>
    
    
      <category term="docker" scheme="http://www.turuwei.com/categories/docker/"/>
    
      <category term="Kitematic" scheme="http://www.turuwei.com/categories/docker/Kitematic/"/>
    
    
      <category term="bug" scheme="http://www.turuwei.com/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>【NLP】自然语言处理 完整流程</title>
    <link href="http://www.turuwei.com/p/10004/"/>
    <id>http://www.turuwei.com/p/10004/</id>
    <published>2020-01-05T09:21:23.000Z</published>
    <updated>2020-01-05T10:40:12.582Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步：获取语料"><a href="#第一步：获取语料" class="headerlink" title="第一步：获取语料"></a>第一步：获取语料</h2><p><strong>语料，即语言材料，是构成语料库的基本单元。</strong> 所以，人们简单地用文本作为替代，并把文本中的上下文关系作为现实世界中语言的上下文关系的替代品。我们把一个文本集合称为语料库（Corpus），当有几个这样的文本集合的时候，我们称之为语料库集合(Corpora)。（定义来源：百度百科）按语料来源，我们将语料分为以下两种：</p><h3 id="1-已有语料"><a href="#1-已有语料" class="headerlink" title="1. 已有语料"></a>1. 已有语料</h3><p>纸质或者电子文本资料—&gt;电子化—&gt;语料库。</p><h3 id="2-网上下载、抓取语料"><a href="#2-网上下载、抓取语料" class="headerlink" title="2. 网上下载、抓取语料"></a>2. 网上下载、抓取语料</h3><p>国内外标准开放数据集（比如国内的中文汉语有搜狗语料、人民日报语料） 或 通过爬虫。</p><h2 id="第二步：语料预处理"><a href="#第二步：语料预处理" class="headerlink" title="第二步：语料预处理"></a>第二步：语料预处理</h2><p>语料预处理大概会占到整个50%-70%的工作量。</p><p>基本过程： 数据清洗—&gt;分词—&gt;词性标注—&gt;去停词</p><h3 id="1-语料清洗"><a href="#1-语料清洗" class="headerlink" title="1. 语料清洗"></a>1. 语料清洗</h3><p>语料清洗：在语料中找到感兴趣的内容，将不感兴趣、视为噪音的内容清洗删除。包括：对于原始文本提取标题、摘要、正文等信息，对于爬虫，去除广告、标签、HTML、JS等代码和注释。</p><p>常见数据清洗方式：人工去重、对齐、删除和标注等，或规则提取内容、正则表达式匹配、根据词性和命名实体提取，编写脚本或代码批处理等。</p><h3 id="2-分词"><a href="#2-分词" class="headerlink" title="2. 分词"></a>2. 分词</h3><p><strong>分词</strong>：将短文本和长文本处理为最小单位粒度是词或词语的过程。</p><p><strong>常见方法</strong>：基于字符串匹配的分词方法、基于理解的分词方法、基于统计的分词方法和基于规则的分词方法，其中每种方法下面对应许多具体的方法。</p><p><strong>难点</strong>：歧义识别 和 新词识别。 eg：“羽毛球拍卖完了”，这个可以切分成“羽毛 球拍 卖 完 了”，也可切分成“羽毛球 拍卖 完 了”—&gt;上下文信息</p><h3 id="3-词性标注"><a href="#3-词性标注" class="headerlink" title="3. 词性标注"></a>3. 词性标注</h3><p><strong>词性标注</strong>：对每个词或词语打词类标签，是一个经典的序列标注问题。eg：形容词、动词、名词等。有助于在后面的处理中融入更多有用的语言信息。</p><p><strong>词性标注不是非必需的。</strong>比如，常见的文本分类就不用关心词性问题，但是类似情感分析、知识推理却是需要的，下图是常见的中文词性整理。</p><p><img src="/p/10004/20190306172401951.png" alt="词性编码"></p><p><strong>常见方法</strong>：基于规则和基于统计的方法。</p><ul><li>基于统计的方法：基于最大熵的词性标注、基于统计最大概率输出词性、基于 HMM、CRF+BiLSTM 的词性标注。</li></ul><h3 id="4-去停用词"><a href="#4-去停用词" class="headerlink" title="4. 去停用词"></a>4. 去停用词</h3><p><strong>停用词</strong>：对文本特征没有任何贡献的字词，eg：标点符号、语气、人称等。</p><p><strong>注意：根据具体场景决定</strong>。eg：在情感分析中，语气词、感叹号是应该保留的，因为他们对表示语气程度、感情色彩有一定的贡献和意义。</p><h2 id="第三步：特征工程"><a href="#第三步：特征工程" class="headerlink" title="第三步：特征工程"></a>第三步：特征工程</h2><p>如何把分词之后的字和词语表示成计算机能够计算的类型。</p><p><strong>思路</strong>：中文分词的字符串—&gt; 向量</p><p>两种常用表示模型：</p><blockquote><ol><li><p>词袋模型（BoW）<br>词袋模型（Bag of Word, BOW)：不考虑词语原本在句子中的顺序，直接将每一个词语或者符号统一放置在一个集合（如 list），然后按照计数的方式对出现的次数进行统计。统计词频这只是最基本的方式，TF-IDF 是词袋模型的一个经典用法。</p></li><li><p>词向量<br>词向量：将字、词语转换为向量矩阵的计算模型。</p><p>常用的词表示方法：</p><ul><li><p>One-Hot：把每个词表示为一个很长的向量。这个向量的维度是词表大小，其中绝大多数元素为 0，只有一个维度的值为 1，这个维度就代表了当前的词。eg: [0 0 0 0 0 0 0 0 1 0 0 0 0 … 0]</p></li><li><p>Word2Vec：其主要包含两个模型：跳字模型（Skip-Gram）和连续词袋模型（Continuous Bag of Words，简称 CBOW），以及两种高效训练的方法：负采样（Negative Sampling）和层序 Softmax（Hierarchical Softmax）。值得一提的是，Word2Vec 词向量可以较好地表达不同词之间的相似和类比关系。</p></li><li><p>Doc2Vec</p></li><li><p>WordRank</p></li><li><p>FastText</p></li></ul></li></ol></blockquote><h2 id="第四步：特征选择"><a href="#第四步：特征选择" class="headerlink" title="第四步：特征选择"></a>第四步：特征选择</h2><p><strong>关键</strong>：如何构造好的特征向量？—&gt; 要选择合适的、表达能力强的特征。</p><p><strong>常见的特征选择方法：DF、 MI、 IG、 CHI、WLLR、WFO 六种。</strong></p><h2 id="第五步：模型训练"><a href="#第五步：模型训练" class="headerlink" title="第五步：模型训练"></a>第五步：模型训练</h2><h3 id="1-模型"><a href="#1-模型" class="headerlink" title="1. 模型"></a>1. 模型</h3><p>对于不同的应用需求，我们使用不同的模型</p><ul><li><p>传统的有监督和无监督等机器学习模型： KNN、SVM、Naive Bayes、决策树、GBDT、K-means 等模型；</p></li><li><p>深度学习模型： CNN、RNN、LSTM、 Seq2Seq、FastText、TextCNN 等。</p></li></ul><h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2. 注意事项"></a>2. 注意事项</h3><h4 id="（1）过拟合"><a href="#（1）过拟合" class="headerlink" title="（1）过拟合"></a>（1）过拟合</h4><p><strong>过拟合</strong>：模型学习能力太强，以至于把噪声数据的特征也学习到了，导致模型泛化能力下降，在训练集上表现很好，但是在测试集上表现很差。</p><p>常见的解决方法有：</p><ul><li><p>增大数据的训练量；</p></li><li><p>增加正则化项，如 L1 正则和 L2 正则；</p></li><li><p>特征选取不合理，人工筛选特征和使用特征选择算法；</p></li><li><p>采用 Dropout 方法等。</p></li></ul><h4 id="（2）欠拟合"><a href="#（2）欠拟合" class="headerlink" title="（2）欠拟合"></a>（2）欠拟合</h4><p><strong>欠拟合</strong>：就是模型不能够很好地拟合数据，表现在模型过于简单。</p><p>常见的解决方法有：</p><ul><li>添加其他特征项；</li><li>增加模型复杂度，比如神经网络加更多的层、线性模型通过添加多项式使模型泛化能力更强；</li><li>减少正则化参数，正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。<h4 id="（3）对于神经网络，注意梯度消失和梯度爆炸问题。"><a href="#（3）对于神经网络，注意梯度消失和梯度爆炸问题。" class="headerlink" title="（3）对于神经网络，注意梯度消失和梯度爆炸问题。"></a>（3）对于神经网络，注意梯度消失和梯度爆炸问题。</h4></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一步：获取语料&quot;&gt;&lt;a href=&quot;#第一步：获取语料&quot; class=&quot;headerlink&quot; title=&quot;第一步：获取语料&quot;&gt;&lt;/a&gt;第一步：获取语料&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;语料，即语言材料，是构成语料库的基本单元。&lt;/strong&gt; 所以，人们简单
      
    
    </summary>
    
    
      <category term="NLP" scheme="http://www.turuwei.com/categories/NLP/"/>
    
    
      <category term="基础" scheme="http://www.turuwei.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>BECOME IMMORTAL求解思路</title>
    <link href="http://www.turuwei.com/p/10003/"/>
    <id>http://www.turuwei.com/p/10003/</id>
    <published>2020-01-04T05:18:20.000Z</published>
    <updated>2020-01-04T05:44:39.865Z</updated>
    
    <content type="html"><![CDATA[<p><strong>这是codewars上一道 1kyu等级的题，刚看到觉得很容易，越想越难，现在还没有一个好的解决办法</strong></p><p><strong>题目如下：</strong></p><blockquote><p><a href="https://www.codewars.com/kata/become-immortal/" target="_blank" rel="noopener"><strong>BECOME IMMORTAL</strong></a></p><blockquote><p>Instructions</p><p>In the nation of CodeWars, there lives an Elder who has lived for a long time. Some people call him the Grandpatriarch, but most people just refer to him as the Elder.</p><p>There is a secret to his longetivity: he has a lot of <code>young</code> worshippers, who regularly perform a ritual to ensure that the Elder stays immortal:</p><ul><li><p>The worshippers lines up in a magic rectangle, of dimensions <code>m</code> and <code>n</code>.</p></li><li><p>They channel their will to wish for the Elder. In this magic rectangle, any worshipper can donate time equal to the <code>xor</code> of the column and the row (zero-indexed) he’s on, in seconds, to the Elder.</p></li><li><p>However, not every ritual goes perfectly. The donation of time from the worshippers to the Elder will experience a transmission loss <code>l</code> (in seconds). Also, if a specific worshipper cannot channel more than <code>l</code> seconds, the Elder will not be able to receive this worshipper’s donation.</p></li></ul><p>The estimated age of the Elder is so old it’s probably bigger than the total number of atoms in the universe. However, the lazy programmers (who <code>made a big news</code> by inventing <a href="https://en.wikipedia.org/wiki/Time_formatting_and_storage_bugs" target="_blank" rel="noopener">the Y2K bug and other related things</a>) apparently didn’t think thoroughly enough about this, and so their <code>simple</code> date-time system can only record time from 0 to <code>t-1</code> seconds. If the elder received the total amount of time (in seconds) more than the system can store, it will be wrapped around so that the time would be between the range 0 to <code>t-1</code>.</p><p>Given <code>m</code>, <code>n</code>, <code>l</code> and <code>t</code>, please find the number of seconds the Elder has received, represented in the poor programmer’s date-time system.</p><p>(Note: <code>t</code> will never be bigger than <code>2^32 - 1</code>, and in JS, <code>2^26 - 1</code>.)</p></blockquote></blockquote><p>我的解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">elder_age</span><span class="params">(m,n,l,t)</span>:</span></span><br><span class="line">    matirc = (max((j^i)-l,<span class="number">0</span>) <span class="keyword">for</span> j <span class="keyword">in</span> range(m) <span class="keyword">for</span> i <span class="keyword">in</span> range(n))</span><br><span class="line">    <span class="keyword">return</span> sum(matirc)%t</span><br></pre></td></tr></table></figure><p>正确结果比较容易求出来，这道题目的难点在于对程序的优化，刚开始想用列表生成式，发现运行时间太长了，就改成了generator，同时这个方法占内存太多，所以算是最粗糙的一个解法了，以后想到了再重新写。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;这是codewars上一道 1kyu等级的题，刚看到觉得很容易，越想越难，现在还没有一个好的解决办法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;题目如下：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;https://www.c
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.turuwei.com/categories/Python/"/>
    
    
      <category term="算法" scheme="http://www.turuwei.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="刷题" scheme="http://www.turuwei.com/tags/%E5%88%B7%E9%A2%98/"/>
    
      <category term="codewars" scheme="http://www.turuwei.com/tags/codewars/"/>
    
  </entry>
  
  <entry>
    <title>Jupyter Lab 简单配置</title>
    <link href="http://www.turuwei.com/p/10002/"/>
    <id>http://www.turuwei.com/p/10002/</id>
    <published>2020-01-03T01:40:03.000Z</published>
    <updated>2020-01-03T02:38:47.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jupyter-Lab-简介"><a href="#Jupyter-Lab-简介" class="headerlink" title="Jupyter Lab 简介"></a>Jupyter Lab 简介</h3><p>Jupyter Lab 是一个交互式的开发环境，是 Jupyter notebook 的下一代产品，集成了更多的功能。也就是说，Jupyter Lab是Jupyter notebook的加强版，用他就对了。</p><p>使用 JupyterLab，你可以：</p><ul><li>可以开启终端，用于交互式运行代码，完全支持丰富的输出</li><li>完美支持 Markdown，Python，R，Julia，LaTeX等任何文本文件</li><li>增强notebook功能</li><li>超多插件支持</li></ul><h3 id="Jupyter-Lab安装"><a href="#Jupyter-Lab安装" class="headerlink" title="Jupyter Lab安装"></a>Jupyter Lab安装</h3><blockquote><p>默认你已经安装了conda</p></blockquote><h4 id="第一种办法-命令行安装"><a href="#第一种办法-命令行安装" class="headerlink" title="第一种办法 命令行安装"></a>第一种办法 命令行安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 下载jupyterlab</span><br><span class="line">pip install jupyterlab</span><br><span class="line"># 安装ipython</span><br><span class="line">pip install ipython</span><br></pre></td></tr></table></figure><h4 id="第二种办法-进入conda图形化界面安装"><a href="#第二种办法-进入conda图形化界面安装" class="headerlink" title="第二种办法 进入conda图形化界面安装"></a>第二种办法 进入conda图形化界面安装</h4><p>点这个，就能启动conda了。</p><p>进入界面你就知道怎么安装了。如果还不会，请自行百度。</p><p><strong>要注意的是，请在合适的python虚拟环境中安装（如果你有多个虚拟环境），这样会省事些。</strong></p><h4 id="Jupyter-Lab-插件安装"><a href="#Jupyter-Lab-插件安装" class="headerlink" title="Jupyter Lab 插件安装"></a>Jupyter Lab 插件安装</h4><p>首先是Jupyter Lab的工作目录的设置，这个和Jupyter notebook的设置是一样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 如果不放心，可以再来一遍</span><br><span class="line">jupyter lab --generate-config</span><br></pre></td></tr></table></figure><p>接着就是插件安装了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 安装一个生成目录的插件</span><br><span class="line">jupyter labextension install @jupyterlab&#x2F;toc</span><br><span class="line"># 可以查看一下安装的插件</span><br><span class="line">jupyter labextension list</span><br></pre></td></tr></table></figure><p>安装完后，打开cmd，输入jupyter lab 进入Jupyter Lab界面。</p><p>点击 Settings –&gt; Advanced Settings Editor ，将Extension Manager 里的enabled 的 false 改成 true（在右边的里面改）。</p><p>现在，看向界面左侧应该就可以看到一个插件管理的图标，点击就可以看到刚才安装的插件</p><p>这个插件还有查询功能，我们可以很方便的安装卸载插件，上面是已安装的插件，下面是可以安装的插件，安装完成后可以直接更新。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Jupyter-Lab-简介&quot;&gt;&lt;a href=&quot;#Jupyter-Lab-简介&quot; class=&quot;headerlink&quot; title=&quot;Jupyter Lab 简介&quot;&gt;&lt;/a&gt;Jupyter Lab 简介&lt;/h3&gt;&lt;p&gt;Jupyter Lab 是一个交互式的开发环
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.turuwei.com/categories/Python/"/>
    
    
      <category term="Jupyter" scheme="http://www.turuwei.com/tags/Jupyter/"/>
    
      <category term="环境配置" scheme="http://www.turuwei.com/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>python中yield用法解析</title>
    <link href="http://www.turuwei.com/p/10001/"/>
    <id>http://www.turuwei.com/p/10001/</id>
    <published>2019-12-31T03:32:59.000Z</published>
    <updated>2019-12-31T03:55:01.128Z</updated>
    
    <content type="html"><![CDATA[<p>之前有看过yield的用法，不过很快就忘掉了，所以再记录一遍。</p><p>我们可以把yield看做“return”，这个是直观的：它首先是个return，return的功能是什么？就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生成器（generator）的一部分（带yield的函数才是真正的迭代器）</p><p><strong>直接上例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"程序开始"</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">"进入循环"</span>)</span><br><span class="line">        res = <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">        print(<span class="string">"res:"</span>,res)</span><br><span class="line">        print(<span class="string">"单次循环结束"</span>)</span><br><span class="line">    print(<span class="string">"循环结束"</span>)</span><br><span class="line">g = test()</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">10</span>)</span><br><span class="line">print(next(g))</span><br><span class="line">print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">print(g.send(<span class="number">7</span>))</span><br></pre></td></tr></table></figure><p><strong>简单的几行代码就让你明白什么是yield，代码的输出这个：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">程序开始</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">**********</span><br><span class="line">res: <span class="literal">None</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br><span class="line">********************</span><br><span class="line">res: <span class="number">7</span></span><br><span class="line">单次循环结束</span><br><span class="line">进入循环</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>接下来逐步解释测试程序的执行：</p><ol><li><p>程序开始执行以后，因为test函数中有yield关键字，所以test函数并不会真的执行，而是先得到一个生成器g(相当于一个对象)</p></li><li><p>直到调用next方法，test函数正式开始执行，先执行test函数中的print方法，然后进入while循环</p></li><li><p>程序遇到yield关键字，然后把yield想想成return,return了一个5之后，程序停止，并没有执行赋值给res操作，此时next(g)语句执行完成，所以输出的前三行（第一个是while上面的print的结果，第二个是while里面的print的结果，第三个是return出的结果）是执行print(next(g))的结果，</p></li><li><p>程序执行print(“*”*10)，输出10个*</p></li><li><p>又开始执行下面的print(next(g)),这个时候和上面那个差不多，不过不同的是，这个时候是从刚才那个next程序停止的地方开始执行的，也就是要执行res的赋值操作，这时候要注意，这个时候赋值操作的右边是没有值的（因为刚才那个是return出去了，并没有给赋值操作的左边传参数），所以这个时候res赋值是None,所以接着下面的输出就是res:None,</p></li><li><p>程序会继续在while里执行，又一次碰到yield,这个时候同样return 出5，然后程序停止，print函数输出的5就是这次return出的5.</p></li><li><p>最后再重复一次，这一次我们调用了send()函数，可以理解为给迭代器g 传递了一个参数，所以能输出res：7。</p></li></ol><p>通过上面这个例子，再结合yield的概念，就能知道yield到底有什么作用了：</p><p>到这里你可能就明白yield和return的关系和区别了，带yield的函数是一个生成器，而不是一个函数了，这个生成器有一个函数就是next函数，next就相当于“下一步”生成哪个数，这一次的next开始的地方是接着上一次的next停止的地方执行的，所以调用next的时候，生成器并不会从test函数的开始执行，只是接着上一步停止的地方开始，然后遇到yield后，return出要生成的数，此步就结束。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有看过yield的用法，不过很快就忘掉了，所以再记录一遍。&lt;/p&gt;&lt;p&gt;我们可以把yield看做“return”，这个是直观的：它首先是个return，return的功能是什么？就是在程序中返回某个值，返回之后程序就不再往下运行了。看做return之后再把它看做一个是生
      
    
    </summary>
    
    
      <category term="Python" scheme="http://www.turuwei.com/categories/Python/"/>
    
    
      <category term="语法" scheme="http://www.turuwei.com/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>生有涯而知无涯</title>
    <link href="http://www.turuwei.com/p/10000/"/>
    <id>http://www.turuwei.com/p/10000/</id>
    <published>2019-12-27T02:39:37.000Z</published>
    <updated>2019-12-27T07:15:55.280Z</updated>
    
    <content type="html"><![CDATA[<p>吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;吾生也有涯，而知也无涯。以有涯随无涯，殆已！已而为知者，殆而已矣！为善无近名，为恶无近刑，缘督以为经，可以保身，可以全生，可以养亲，可以尽年。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="http://www.turuwei.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="随笔" scheme="http://www.turuwei.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
